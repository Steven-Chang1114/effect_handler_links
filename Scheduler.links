alien javascript "js/runtime.js" {
    delayExecution: (Int) ~> ();
    sysEnqueue: (a) ~> ();
    sysDequeue: () ~> [a];
}

typename Queue(a) = (rear: [a], front: [a]);
typename PrioQueue(a) = (high: Queue(a), medium: Queue(a), low: Queue(a));
typename Priority = [|High|Medium|Low|];
typename Fiber0(e::Eff) = (prio: Priority, f: () {Fork: (Fiber0({ |e})) => (), Yield:() |e}~> ());
typename SchedulerState(a) = (runQ: PrioQueue(a), prio: Priority, startTime: Int);
typename Fiber(e::Eff) = (prio:Priority, f: (SchedulerState(Fiber({ |e}))) ~e~> ());
typename FiberQueue(e::Eff) = PrioQueue(Fiber({ |e}));

sig enqueue: (a, Queue(a)) -> Queue(a)
fun enqueue(x, q){
    (q with rear=x::q.rear)
}

sig dequeue: (Queue(a)) ~> (Maybe(a), Queue(a))
fun dequeue(q){
    switch(q) {
        case (rear=[], front=[]) -> (Nothing, q)
        case (rear=xs, front=[]) ->
          var q0 = (rear=[], front=reverse(xs));
          dequeue(q0)
        case (rear=ys, front=(x :: xs)) ->
          var q0 = (rear=ys, front=xs);
          (Just(x), q0)
    }
}

sig priorityEnqueue: (a, Priority, PrioQueue(a)) ~> PrioQueue(a)
fun priorityEnqueue(x, prio, pq){
    switch(prio){
        case High -> (pq with high = enqueue(x, pq.high))
        case Medium -> (pq with medium = enqueue(x, pq.medium))
        case Low -> (pq with low = enqueue(x, pq.low))
    }
}

sig priorityDequeue: (PrioQueue(a)) ~> (Maybe((a, Priority)), PrioQueue(a) )
fun priorityDequeue(pq){
    switch(dequeue(pq.high)){
        case (Just(x), q) -> (Just((x, High)), (pq with high= q))
        case (Nothing,_) ->
            switch(dequeue(pq.medium)){
                case (Just(x), q) -> (Just((x, Medium)), (pq with medium= q))
                case (Nothing,_) ->
                    switch(dequeue(pq.low)){
                        case (Nothing, _) -> (Nothing, pq)
                        case (Just(x), q) -> (Just((x, Low)), (pq with low=q))
                    }
            }
    }
}

sig fiberEnqueue: (Fiber({ |e}), FiberQueue({ |e})) ~> FiberQueue({ |e})
fun fiberEnqueue(f, q){
    priorityEnqueue(f, f.prio, q)
}

sig fiberBulkEnqueue: ([Fiber({ |e})], FiberQueue({ |e})) ~> FiberQueue({ |e})
fun fiberBulkEnqueue(fibers, q){
    switch(fibers){
        case [] -> q
        case x::xs ->
            var pq = fiberEnqueue(x, q);
            fiberBulkEnqueue(xs, pq)
    }
}

sig fiberDequeue: (FiberQueue({ |e})) ~> (Maybe((Fiber({ |e}), Priority)), FiberQueue({ |e}))
fun fiberDequeue(q){
    priorityDequeue(q)
}

fun emptyQueue(){
    (rear=[], front=[])
}

fun emptyPrioQueue(){
    (high= emptyQueue(), medium=emptyQueue(), low=emptyQueue())
}

sig fiberQueueLength: (FiberQueue({ |e}))  -> Int
fun fiberQueueLength(q){
    length(q.low.rear) + length(q.high.front) + length(q.high.rear) + length(q.medium.front) + length(q.medium.rear) + length(q.low.front)
}

sig fork : (Fiber0({ |e})) {Fork: (Fiber0({ |e})) => (), Yield:() |e}~> ()
fun fork(f){
    do Fork(f)
}

sig yield: () {Yield:() |e}~> ()
fun yield(){
    do Yield
}

sig makeFiber: (Priority, () {Fork: (Fiber0({ |e})) => (), Yield:() |e}~> ()) -> Fiber0({ |e})
fun makeFiber(prio, f){
    (prio= prio, f=f)
}

sig forever: () {Yield:() |e}~> ()
fun forever(){ yield(); forever()}

sig schedule: (Fiber0({ |e})) {Yield-, Fork- | e}~> ()
fun schedule(main){

    #sig makeSchedulerState: (Priority, PrioQueue(a)) ~> SchedulerState(a)
    fun makeSchedulerState(prio, q){
        (runQ = q, prio = prio, startTime = clientTimeMilliseconds())
    }

    fun runNext(q){
        switch(fiberDequeue(q)){
            case (Nothing, _) -> ()
            case (Just((fiber, prio)), q) -> fiber.f(makeSchedulerState(prio, q))
        }
    }

    fun resumptionToFiber(resume, prio){
        (prio = prio, f = fun(state) { resume((), state) })
    }

    mutual {
      #sig fiber0ToFiber: (Fiber0({ |%e})) ~%~> Fiber({ |%e})
      fun fiber0ToFiber(fiber){
          (prio = fiber.prio, f = fun(state) { runFiber(fiber, state.runQ ) })
      }

      #sig poll: (FiberQueue({ |e})) ~> FiberQueue({ |e})
      fun poll(q){
          var enqueue = map(fiber0ToFiber, sysDequeue());
          fiberBulkEnqueue(enqueue, q)
      }

      fun runFiber(fiber, runQ){
          println("runQ: " ^^ intToString(fiberQueueLength(runQ)));
          #dump(self());
          handle(fiber.f()) ( state <- (prio=fiber.prio, runQ=runQ, startTime=clientTimeMilliseconds()) ){
              case x ->
                    print("RUN");
                  runNext(poll(state.runQ))
              case <Fork(f) => resume> ->
                    print("fork");
                    var q = poll(state.runQ);
                    # f is new fiber, state.prio is the current fiber
                    switch ((f.prio, state.prio)) {
                      case (High, _) ->
                          # Enqueue the current fiber, run the new fiber
                          var qq = fiberEnqueue(resumptionToFiber(resume, state.prio), state.runQ);
                          runFiber(f, qq)
                      case (Medium, High) ->
                          # Enqueue the new fiber, run the current fiber
                          var qq = fiberEnqueue(fiber0ToFiber(f), state.runQ);
                          resume((), (state with runQ = qq))
                      case (Medium, _) ->
                          # Enqueue the new fiber, run the current fiber
                          var qq = fiberEnqueue(resumptionToFiber(resume, state.prio), state.runQ);
                          runFiber(f, qq)
                      case (_,_) ->
                          # Enqueue the current fiber, run the new fiber
                          var qq = fiberEnqueue(resumptionToFiber(resume, state.prio), state.runQ);
                          runFiber(f, qq)
                    }
              case <Yield => resume> ->
                    print("YIELD");
                  var currentTime = clientTimeMilliseconds();
                  var buffer = switch(state.prio){
                      case High -> 400
                      case Medium ->200
                      case Low -> 100
                  };
                  if (currentTime - state.startTime <= buffer) {
                    print("RESUME"); 
                    resume((), state)
                  } else{
                    print("SWITCH");
                      var q = fiberEnqueue(resumptionToFiber(resume, state.prio), state.runQ);
                      runNext(q)
                  }
          }
      }
    }

    runFiber(main, emptyPrioQueue())

}

fun main() {
    addStaticRoute("/js", "js", [("js", "text/javascript")])
}

main()